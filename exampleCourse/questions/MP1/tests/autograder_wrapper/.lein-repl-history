(use '[autograder-wrapper.autograder :as ag])
(ag/main)
(println output_results)
(testCommunistPlus)
(println output_results)
              (conj output_results "Test communist-plus")
(println output_results)
              (conj! output_results "Test communist-plus")
(def res '())
              (conj! res "Test communist-plus")
              (def output_results (conj output_results "Test communist-plus"))
              (def test (conj output_results "Test communist-plus"))
              (def test_res (conj output_results "Test communist-plus"))
              (def test_res (conj test_res "Test communist-plus"))
(println test_res)
test_res
quit
(use 'autograder-wrapper.autograder)
(use '[autograder-wrapper.autograder :as ag])
(ag/main)
(plus 10)
(plus 10 20)
(plus)
(plus 10 20 30 40 50)
(eval '(plus 10 20 30 40 50))
              (cond (identical? (eval 'plus) 0)
                (def score (inc score))
                :else 0)
              (cond (identical? (eval '(plus 10)) 10)
                (def score (inc score))
                :else 0)
              (cond (identical? (eval '(plus 10 20)) 30)
                (def score (inc score))
                :else 0)
              (cond (identical? (eval '(plus 10 20 30 40 50)) 150)
                (def score (inc score))
                :else 0)
quit
(use 'initial.core)
              (cond (identical? (eval 'plus) 0)
                (def score (inc score))
                :else 0)
              (cond (identical? (eval '(plus 10)) 10)
                (def score (inc score))
                :else 0)
              (cond (identical? (eval '(plus 10 20)) 30)
                (def score (inc score))
                :else 0)
              (cond (identical? (eval '(plus 10 20 30 40 50)) 150)
                (def score (inc score))
                :else 0)
(def score 0)
              (cond (identical? (eval 'plus) 0)
                (def score (inc score))
                :else 0)
(eval 'plus)
(eval '(plus))
              (cond (identical? (eval '(plus)) 0)
                (def score (inc score))
                :else 0)
(print score)
              (cond (identical? (eval '(plus 10)) 10)
                (def score (inc score))
                :else 0)
              (cond (identical? (eval '(plus 10 20)) 30)
                (def score (inc score))
                :else 0)
              (cond (identical? (eval '(plus 10 20 30 40 50)) 150)
                (def score (inc score))
                :else 0)
(identical? (eval '(plus 10 20 30 40 50)) 150)
(eval '(plus 10 20 30 40 50))
(= (eval '(plus 10 20 30 40 50)) 150)
quit
(use '[autograder-wrapper.autograder :as ag])
(ag/main)
quit
(use '[autograder-wrapper.autograder :as ag])
(ag/main)
(count (ag/main))
(use '[clojure.string :as str])
(count (str/split ag/main #"\d+"))
(count (str/split (ag/main) #"\d+"))
(println (str/split (ag/main) #"\d+"))
((str/split (ag/main) #"\d+"))
(str/split (ag/main) #"\d+")
(ag/main)
(str/split-lines (ag/main))
(count (str/split-lines (ag/main)))
(quit)
(use '[clojure.string :as str])
(use '[autograder-wrapper.autograder :as ag])
(count (str/split-lines (ag/main)))
mod (count (str/split-lines (ag/main))))
(mod (count (str/split-lines (ag/main))))
(mod (count (str/split-lines (ag/main)))
)
(mod (count (str/split-lines (ag/main))) 6 )
(= (mod (count (str/split-lines (ag/main))) 6 ) 0)
(> (count (str/split-lines (ag/main))) 1 )
(and (> (count (str/split-lines (ag/main))) 1 ) (= (mod (count (str/split-lines (ag/main))) 6 ) 0))
(cond (and (> (count (str/split-lines (ag/main))) 1 ) (= (mod (count (str/split-lines (ag/main))) 6 ) 0))
(println 5)
:else "Lol"
)
(cond (and (> (count (str/split-lines (ag/main))) 1 ) (= (mod (count (str/split-lines (ag/main))) 6 ) 0))
(do 
(println 5)
(println 7)
)
:else "Lol"
)
(def lines (str/split-lines (ag/main)))
lines
(count lines)
quit
